# Benchmark Report

## Job Properties

*Commit(s):* [JuliaLang/julia@54756fb](https://github.com/JuliaLang/julia/commit/54756fb08dcdc0edc2767361fd2f28ceb658c038) vs [JuliaLang/julia@4091c1d](https://github.com/JuliaLang/julia/commit/4091c1df8c0d92a30c353caab5f0e8be4fd21521)

*Tag Predicate:* `"array"`

*Triggered By:* [link](https://github.com/JuliaLang/julia/pull/14957#issuecomment-181138505)

## Results

Below is a table of this job's results. If available, the data used to generate this
table can be found in the JSON file in this directory.

Benchmark definitions can be found in [JuliaCI/BaseBenchmarks.jl](https://github.com/JuliaCI/BaseBenchmarks.jl).

The ratio values in the below table equal `primary_result / comparison_result` for each corresponding
metric. Thus, `x < 1.0` would denote an improvement, while `x > 1.0` would denote a regression.
Note that a default tolerance of `0.2` is applied to account for the variance of our test
hardware.

Regressions are marked with :x:, while improvements are marked with :white_check_mark:. GC
measurements are [not considered when determining regression status](https://github.com/JuliaCI/BenchmarkTrackers.jl/issues/5).

Only benchmarks with significant results - results that indicate regressions or improvements - are
shown below (an empty table means that all benchmark results remained invariant between builds).

| Group ID | Benchmark ID | time | time spent in GC | bytes allocated | number of allocations |
|----------|--------------|------|------------------|-----------------|-----------------------|
| `array index sum` | `(:sumcolon,"BaseBenchmarks.ArrayBenchmarks.ArrayLSLS{Int32,2}",(300,500))` | **1.35** :x: | 1.31 | 1.0 | 1.0 |
| `array index sum` | `(:sumcolon,"BaseBenchmarks.ArrayBenchmarks.ArrayLS{Int32,2}",(300,500))` | **1.33** :x: | 1.3 | 1.0 | 1.0 |
| `array index sum` | `(:sumcolon,"SubArray{Int32,2,Array{Int32,2},Tuple{UnitRange{Int64},UnitRange{Int64}},1}",(300,500))` | **1.21** :x: | 1.2 | 1.0 | 1.0 |
| `array index sum` | `(:sumeach,"BaseBenchmarks.ArrayBenchmarks.ArrayLS{Int32,2}",(3,5))` | **2.12** :x: | 1.0 | 1.0 | 1.0 |
| `array index sum` | `(:sumlinear,"SubArray{Float32,2,Array{Float32,2},Tuple{UnitRange{Int64},UnitRange{Int64}},1}",(3,5))` | **0.59** :white_check_mark: | 1.0 | **0.06** :white_check_mark: | **0.06** :white_check_mark: |
| `array index sum` | `(:sumlinear,"SubArray{Float32,2,Array{Float32,2},Tuple{UnitRange{Int64},UnitRange{Int64}},1}",(300,500))` | **0.46** :white_check_mark: | 0.0 | **0.0** :white_check_mark: | **0.0** :white_check_mark: |
| `array index sum` | `(:sumlinear,"SubArray{Int32,2,Array{Int32,2},Tuple{UnitRange{Int64},UnitRange{Int64}},1}",(3,5))` | **0.67** :white_check_mark: | 1.0 | 1.0 | 1.0 |
| `array index sum` | `(:sumlinear,"SubArray{Int32,2,Array{Int32,2},Tuple{UnitRange{Int64},UnitRange{Int64}},1}",(300,500))` | **0.46** :white_check_mark: | 0.0 | **0.0** :white_check_mark: | **0.0** :white_check_mark: |
| `array index sum` | `(:sumlogical,"Array{Float32,2}",(3,5))` | **0.75** :white_check_mark: | 1.0 | 1.0 | 1.0 |
| `blas 1` | `(:axpy!,1024)` | **1.21** :x: | 1.0 | 1.0 | 1.0 |
| `blas 1` | `(:dot,256)` | **1.22** :x: | 1.0 | 1.0 | 1.0 |
| `lapack eig` | `(:realeig,16)` | **0.65** :white_check_mark: | 1.0 | 1.0 | 1.0 |
| `lapack eig` | `(:symeig,16)` | **0.77** :white_check_mark: | 1.0 | 1.0 | 1.0 |
| `simd` | `(:conditional_loop!,"Int64",999)` | **1.39** :x: | 1.0 | 1.0 | 1.0 |
| `simd` | `(:conditional_loop!,"Int64",1000)` | **1.38** :x: | 1.0 | 1.0 | 1.0 |
| `simd` | `(:inner,"Float64",256)` | **1.21** :x: | 1.0 | 1.0 | 1.0 |
| `simd` | `(:loop_fields!,"BaseBenchmarks.SIMDBenchmarks.ImmutableFields{V<:AbstractArray{T,1}}","Float64",256)` | **1.38** :x: | 1.0 | 1.0 | 1.0 |
| `simd` | `(:loop_fields!,"BaseBenchmarks.SIMDBenchmarks.ImmutableFields{V<:AbstractArray{T,1}}","Float64",999)` | **0.76** :white_check_mark: | 1.0 | 1.0 | 1.0 |
| `simd` | `(:loop_fields!,"BaseBenchmarks.SIMDBenchmarks.MutableFields{V<:AbstractArray{T,1}}","Float64",256)` | **1.38** :x: | 1.0 | 1.0 | 1.0 |
| `simd` | `(:loop_fields!,"BaseBenchmarks.SIMDBenchmarks.MutableFields{V<:AbstractArray{T,1}}","Float64",999)` | **0.76** :white_check_mark: | 1.0 | 1.0 | 1.0 |
| `simd` | `(:manual_example!,"Float64",256)` | **1.21** :x: | 1.0 | 1.0 | 1.0 |
| `sparse matrix column indexing` | `("range",1000,31593,199)` | **0.8** :white_check_mark: | 1.0 | 1.0 | 1.0 |
| `sparse vector indexing` | `("dense logical",1000,37)` | **0.59** :white_check_mark: | 1.0 | 1.0 | 1.0 |

## Version Info

#### Primary Build

```
Julia Version 0.5.0-dev+2524
Commit 54756fb (2016-02-07 23:05 UTC)
Platform Info:
  System: Linux (x86_64-linux-gnu)
  CPU: Intel(R) Xeon(R) CPU E3-1241 v3 @ 3.50GHz
  WORD_SIZE: 64
           Ubuntu 14.04.3 LTS
  uname: Linux 3.13.0-65-generic #105-Ubuntu SMP Mon Sep 21 18:50:58 UTC 2015 x86_64 x86_64
Memory: 31.383678436279297 GB (20418.21484375 MB free)
Uptime: 1.1260678e7 sec
Load Avg:  3.99169921875  6.05224609375  5.869140625
Intel(R) Xeon(R) CPU E3-1241 v3 @ 3.50GHz: 
       speed         user         nice          sys         idle          irq
#1  3501 MHz    5061538 s        499 s    1849107 s  1117192540 s          9 s
#2  3501 MHz    3992684 s        116 s    1682098 s  1118464852 s          1 s
#3  3501 MHz    3536861 s       1251 s    1392829 s  1119874246 s          1 s
#4  3501 MHz    2759441 s        318 s    1428685 s  1120687814 s          0 s
#5  3501 MHz    1842972 s       3166 s     577206 s  1123411731 s          0 s
#6  3501 MHz    1511639 s        544 s     577391 s  1122643353 s          0 s
#7  3501 MHz    1965426 s       1047 s     616842 s  1123185913 s          0 s
#8  3501 MHz    1795668 s       1614 s     490412 s  1123558903 s          0 s

  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY Haswell)
  LAPACK: libopenblas64_
  LIBM: libopenlibm
  LLVM: libLLVM-3.7.1

```

#### Comparison Build

```
Julia Version 0.5.0-dev+2519
Commit 4091c1d (2016-02-07 22:53 UTC)
Platform Info:
  System: Linux (x86_64-linux-gnu)
  CPU: Intel(R) Xeon(R) CPU E3-1241 v3 @ 3.50GHz
  WORD_SIZE: 64
           Ubuntu 14.04.3 LTS
  uname: Linux 3.13.0-65-generic #105-Ubuntu SMP Mon Sep 21 18:50:58 UTC 2015 x86_64 x86_64
Memory: 31.383678436279297 GB (20413.6796875 MB free)
Uptime: 1.1263597e7 sec
Load Avg:  3.37109375  5.6171875  5.8466796875
Intel(R) Xeon(R) CPU E3-1241 v3 @ 3.50GHz: 
       speed         user         nice          sys         idle          irq
#1  3501 MHz    5156939 s        499 s    1897292 s  1117326008 s         10 s
#2  3501 MHz    4105782 s        116 s    1747900 s  1118557588 s          1 s
#3  3501 MHz    3624511 s       1251 s    1459169 s  1119995308 s          1 s
#4  3501 MHz    2838897 s        318 s    1490724 s  1120821857 s          0 s
#5  3501 MHz    1911082 s       3166 s     651004 s  1123552795 s          0 s
#6  3501 MHz    1579044 s        544 s     650734 s  1122783980 s          0 s
#7  3501 MHz    2057156 s       1047 s     679284 s  1123315330 s          0 s
#8  3501 MHz    1863309 s       1614 s     563835 s  1123701378 s          0 s

  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY Haswell)
  LAPACK: libopenblas64_
  LIBM: libopenlibm
  LLVM: libLLVM-3.7.1

```

## Benchmark Group List

Here's a list of all the benchmark groups executed by this job:

- `array bool`
- `array cat`
- `array comprehension`
- `array growth`
- `array index load reverse`
- `array index setindex!`
- `array index sum`
- `array subarray`
- `blas 1`
- `blas 2`
- `blas 3`
- `lapack chol`
- `lapack eig`
- `lapack lu`
- `lapack qr`
- `lapack schur`
- `lapack svd`
- `problem laplacian`
- `simd`
- `sparse matrix column indexing`
- `sparse matrix row + column indexing`
- `sparse matrix row indexing`
- `sparse matrix transpose`
- `sparse vector indexing`
